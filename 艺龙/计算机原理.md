* 分布：
  * 单选 1
  * 多选 3


* 计算机原理    6
  * 题目1
    * 下面那些情况会导致从用户态切到系统态\(\)
      * A:fork\(\)
      * B:缺页异常
      * C:硬盘读写操作完成
      * D:Linux的int 80h中断
    * 答案 A.B.C.D
      * 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
        * 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork\(\)实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。
        * 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
        * 外围设备的中断： 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
      * 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态 到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而 异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态 的步骤主要包括：
        * 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
        * 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令
        * 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。
  * 题目2
    * 某虚拟内存系统采用LRU算法的页式内存管理，考虑下面页面访问地址流（每次访问在一个时间单位内完成）：1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3,7；假定内存容量为4个页面，开始是空的，则页面失效的次数为（）
      * A: 7
      * B: 5
      * C: 6
      * D: 4
    * 答案：C
      * ![](/assets/import.png)
  * 题目3
    * 同一进程下的线程可以共享如下哪些内容：()
      * A: stack
      * B: data section
      * C: register set
      * D: file fd
    * 答案： BD
      * 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位
      * 程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
      * 一个线程可以创建和撤销另一个线程
      * 同一个进程中的多个线程之间可以并发执行
      * 进程在执行过程中拥有独立的内存单元，而该进程的多个线程共享内存，从而极大地提高了程序的运行效率。 
      * 堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏
      * 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放
      * 线程共享的内容包括：
        * 进程代码段
        * 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、
        * 进程打开的文件描述符、
        * 信号的处理器、
        * 进程的当前目录和
        * 进程用户ID与进程组ID
      * 线程独有的内容包括：
        * 线程ID
        * 寄存器组的值
        * 线程的堆栈
        * 错误返回码
        * 线程的信号屏蔽码
  * 题目4
    * 在linux中，对于多进程，子进程会继承父进程的那些内容（）
      * A: 进程地址空间
      * B: 共享内存
      * C: 信号掩码
      * D: 已打开的文件描述符
      * E: 以上都不是
    * 答案：B.C.D
      * fork出来的子进程，基本上除了进程号之外父进程的所有东西都有一份拷贝，基本就意味着不是全部，子进程得到的只是父进程的拷贝，而不是父进程资源的本身。
      * 子进程自父进程继承到：     
        * 进程的资格(真实(real)/有效(effective)/已保存(saved)用户号(UIDs)和组号(GIDs))
        * 环境(environment)
        * 堆栈
        * 内存
        * 打开文件的描述符(注意对应的文件的位置由父子进程共享，这会引起含糊情况)
        * 执行时关闭(close-on-exec) 标志 (译者注：close-on-exec标志可通过fnctl()对文件描述符设置，POSIX.1要求所有目录流都必须在exec函数调用时关闭。更详细说明，参见《UNIX环境高级编程》 W. R. Stevens, 1993, 尤晋元等译(以下简称《高级编程》), 3.13节和8.9节)
        * 信号(signal)控制设定
        * nice值 (译者注：nice值由nice函数设定，该值表示进程的优先级，数值越小，优先级越高)
        * 进程调度类别(scheduler class)(译者注：进程调度类别指进程在系统中被调度时所属的类别，不同类别有不同优先级，根据进程调度类别和nice值，进程调度程序可计算出每个进程的全局优先级(Global process prority)，优先级高的进程优先执行)
        * 进程组号
        * 对话期ID(Session ID) (译者注：译文取自《高级编程》，指：进程所属的对话期(session)ID， 一个对话期包括一个或多个进程组， 更详细说明参见《高级编程》9.5节)
        * 当前工作目录
        * 根目录 (译者注：根目录不一定是“/”，它可由chroot函数改变)
        * 文件方式创建屏蔽字(file mode creation mask (umask))(译者注：译文取自《高级编程》，指：创建新文件的缺省屏蔽字)
        * 资源限制
        * 控制终端
      * 子进程独有
        * 进程号，不同的父进程号(译者注：即子进程的父进程号与父进程的父进程号不同， 父进程号可由getppid函数得到)
        * 自己的文件描述符和目录流的拷贝(译者注：目录流由opendir函数创建，因其为顺序读取，顾称“目录流”)
        * 子进程不继承父进程的进程，正文(text)， 数据和其它锁定内存(memory locks)(译者注：锁定内存指被锁定的虚拟内存页，锁定后，4.不允许内核将其在必要时换出(page out)，详细说明参见《The GNU C Library Reference Manual》 2.2版， 1999, 3.4.2节)
        * 在tms结构中的系统时间(译者注：tms结构可由times函数获得，它保存四个数据用于记录进程使用中央处理器 (CPU：Central Processing Unit)的时间，包括：用户时间，系统时间， 用户各子进程合计时间，系统各子进程合计时间)
        * 资源使用(resource utilizations)设定为0
        * 阻塞信号集初始化为空集(译者注：原文此处不明确，译文根据fork函数手册页稍做修改)
        * 不继承由timer_create函数创建的计时器
        * 不继承异步输入和输出
      * 孤儿进程: 如果父进程先退出,子进程还没退出那么子进程将被 托孤给init进程,这是子进程的父进程就是init进程(1号进程)
      * init进程没有父进程
      * 僵尸进程: 进程终止后进入僵死状态(zombie),等待告知父进程自己终止,后才能完全消失.但是如果一个进程已经终止了,但是其父进程还没有获取其状态,那么这个进程就称之为僵尸进程.僵尸进程还会消耗一定的系统资源,并且还保留一些概要信息供父进程查询子进程的状态可以提供父进程想要的信息.一旦父进程得到想要的信息,僵尸进程就会结束
    * 题目5
      * 