* 计算机原理    6

  * 题目1
    * 下面那些情况会导致从用户态切到系统态\(\)
      * A:fork\(\)
      * B:缺页异常
      * C:硬盘读写操作完成
      * D:Linux的int 80h中断
    * 答案 A.B.C.D
      * 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
        * 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork\(\)实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。
        * 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
        * 外围设备的中断： 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
      * 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态 到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而 异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态 的步骤主要包括：
        * 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
        * 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令
        * 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。
  * 题目2
    * 某虚拟内存系统采用LRU算法的页式内存管理，考虑下面页面访问地址流（每次访问在一个时间单位内完成）：1,8,1,7,8,2,7,2,1,8,3,8,2,1,3,1,7,1,3,7；假定内存容量为4个页面，开始是空的，则页面失效的次数为（）
      * A: 7
      * B: 5
      * C: 6
      * D: 4
    * 答案：C
      * ![](/assets/import.png)
  * 题目3
    * 同一进程下的线程可以共享如下哪些内容：()
      * A: stack
      * B: data section
      * C: register set
      * D: file fd
    * 答案： BD
      * 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位
      * 程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈)，但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
      * 一个线程可以创建和撤销另一个线程
      * 同一个进程中的多个线程之间可以并发执行
      * 进程在执行过程中拥有独立的内存单元，而该进程的多个线程共享内存，从而极大地提高了程序的运行效率。 
      * 堆：是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏
      * 栈：是个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是　thread safe的。操作系统在切换线程的时候会自动的切换栈，就是切换　ＳＳ／ＥＳＰ寄存器。栈空间不需要在高级语言里面显式的分配和释放
      * 线程共享的内容包括：
        * 进程代码段
        * 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、
        * 进程打开的文件描述符、
        * 信号的处理器、
        * 进程的当前目录和
        * 进程用户ID与进程组ID
      * 线程独有的内容包括：
        * 线程ID
        * 寄存器组的值
        * 线程的堆栈
        * 错误返回码
        * 线程的信号屏蔽码
