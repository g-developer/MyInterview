#### 结构
* 单选 20题 Done：5
* 多选 10题 Done：5
* 问答 2题

#### 分配
* 网络    6
    * 题目1 
        * 当使用TCP协议编程时，下列问题哪个是必须由程序员考虑和处理的()
            * A: 乱序数据包的重传
            * B: 数据传输过程中的纠错
            * C: 网络拥塞处理
            * D: 发送数据的格式和应用层协议
        * 答案 D 
* 数据结构与算法    6
    * 题目 1
        * 在KMP算法中，已知模式串为ADABCADADA，请写出模式串的next数组值（ ）
            * A：-1,0,0,1,0,0,1,2,3,2
            * B：0,1,2,1,0,0,1,3,3,2
            * C：-1,0,0,0,1,0,1,2,3,2
            * D：1,0,0,1,0,0,1,2,2,3
        * 答案 A
            * "前缀"指除了最后一个字符以外，一个字符串的全部头部组合
            * "后缀"指除了第一个字符以外，一个字符串的全部尾部组合
            * next数组值就是"前缀"和"后缀"的最长的共有元素的长度。
            * 首先求最大相同前缀后缀长度。"A"的前缀和后缀都为空集，没有共有元素，共有元素长度为0；"AD"的前缀为[A]，后缀为[D]，没有共有元素，共有元素长度为0；"ADA"的前缀为 [A, AD]，后缀为[DA, A]，共有元素为A，长度为1；"ADAB"的前缀为[A, AD, ADA]，后缀为[DAB, AB,B ]，共有元素长度为0；以此类推，最大公共元素长度为0,0,1,0,0,1,2,3,2。
            * 然后将最长相同前缀后缀长度值右移一位，并将next[0]初值赋为-1，得到的next数组：-1,0,0,1,0,0,1,2,3,2。
* 数据库    6
    * 题目1
        * 事务的特性有哪些()
            A:原子性
            B:一致性
            C:隔离性
            D:持久性
        * 答案： A.B.C.D
    * 题目2
        * 
* 多线程    6
    * 题目1
        * 并发操作会带来哪些数据不一致性（ ）
            * A：丢失修改、脏读、死锁
            * B：不可重复读、脏读、死锁
            * C：不可修改、不可重复读、脏读、死锁
            * D：丢失修改、不可重复读、脏读
        * 答案 D
            * 并发操作指的是多用户或多事务同时对同一数据进行操作。
            * 当两个或多个事务选择同一数据，并且基于最初选定的值修改该数据时，会发生丢失修改问题。每个事务都不知道其它事务的存在，最后的更新将重写由其它事务所做的更新，这将导致修改丢失。
            * 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据。
            * 一个事务重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务修改过。即事务1读取某一数据后，事务2对其做了修改，当事务1再次读数据时，得到的与第一次不同的值。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
            * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
    * 题目2
        * 以下不是进程间通讯的是()
            * A:共享内存
            * B:信号
            * C:线程局部存储
            * D:消息队列
        * 答案：C
            * 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。
            * 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
            * 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
            * 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
            * 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
            * 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
            * 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。
            * 区别
                * 共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据（配合信号量使用）；这种方式通常适用于多进程间通信
                * PIPE和FIFO用来实现进程间相互发送非常短小的、频率很高的消息；这两种方式通常适用于两个进程间的通信
                * 分布式开发。在多进程、多线程、多模块所构成的今天最常见的分布式系统开发中，socket是第一选择
                * PIPE和FIFO可以偶尔使用下，共享内存都用的不多了。在效率上说，socket有包装数据和解包数据的过程，所以理论上来说socket是没有PIPE/FIFO快。不过现在计算机上真心不计较这么一点点速度损失的。
                * 程间通信的数据一般来说我们都会存入数据库的，这样万一某个进程突然死掉或者整个服务器死了，也不至于丢失重要数据、便于回滚到之前的状态
                * 共享内存的效率确实高，但它的重点在“共享”二字上。如果的确有好些进程共享一大块数据。如果把每个进程都看做是类的对象的话，那么共享数据就是这个类的static数据成员），那么共享内存就是一个不二的选择了。但是在面向对象的今天，我们更多的时候是多线程+锁+线程间共享数据。因此共享进程在今天使用的也越来越少了
                * 在面对一些极度追求效率的需求时，共享内存就会成为唯一的选择，比如高频交易系统。除此以外，一般是不需要特意使用共享内存的
                * PIPE和共享内存是不能跨LAN的（FIFO可以但FIFO只能用于两个进程通信）。如果你的分布式系统随着需求的增加而越来越大所以你想把不同的模块放在不同机器上而你之前开发的时候用了PIPE或者共享内存，那么你将不得不对代码进行大幅修改。同时，即使FIFO可以跨越LAN，其代码的可读性、易操作性和可移植性、适应性也远没有socket大
                * 信号的局限性：不能跨LAN、信息量极其有限
        * 题目3
            * 产生死锁的条件是（ ）
                * A：资源不能被共享
                * B：请求与保持条件
                * C：非剥夺条件
                * D：循环等待条件
            * 答案 A.B.C.D
                * 资源不能被共享，只能由一个进程使用。
                * 请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
                * 非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
                * 循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。
 
* 计算机原理    6
        * 题目1
            * 下面那些情况会导致从用户态切到系统态()
                * A:fork()
                * B:缺页异常
                * C:硬盘读写操作完成
                * D:Linux的int 80h中断
            * 答案 A.B.C.D
                * 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
                    * 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。
                    * 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。
                    * 外围设备的中断： 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
                * 从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态 到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而 异常和中断的处理机制基本上也是一致的，关于它们的具体区别这里不再赘述。关于中断处理机制的细节和步骤这里也不做过多分析，涉及到由用户态切换到内核态 的步骤主要包括：
                    * 从当前进程的描述符中提取其内核栈的ss0及esp0信息。
                    * 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令
                    * 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

* Java/C/shell    6
    * 题目1
        * 使用malloc系统调用分配内存是在()上分配的
            * A:栈
            * B:bass
            * C:物理内存
            * D:堆
        * 答案 D
    * 题目2
        * 关于strcpy和memset区别，说法正确的是()
            * A: strcpy只能复制字符串
            * B: memcpy可以复制任意内容
            * C: strcpy不需要指定长度，它遇到被复制字符的串结束符"\0"才结束
            * D: memcpy则是根据其第3个参数决定复制的长度
        * 答案： A.B.C.D
    * 题目3
        * 关于&和nohub说法正确的是()
            * A: &是指在后台运行
            * B: &当用户推出(挂起)的时候，命令自动也跟着退出
            * C: nohup运行由 Command参数和任何相关的 Arg参数指定的命令，忽略所有挂断（SIGHUP）信号
            * D: nohup启动的命令不能被kill
        * 答案 A.B.C
    * 题目4
         * 对如下C语言程序在普通X86 PC上面运行时候的输出叙述正确的是()
         ```C
            #include <stdlib.h>
            #include <stdio.h>
            char *f(){
                    char x[512];
                    sprintf (x, "hello world");
                    return x[6];
            }
            void main(){
                    printf("%s\n",f());
            }
            ```   
            * A: 程序可能崩溃，也可能输出hello world
            * B: 程序可能崩溃，也可能输出world
            * C: 程序可能崩溃，也可能输出hello
            * D: 程序一定会崩溃
        * 答案
            * B