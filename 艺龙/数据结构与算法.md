* 数据结构与算法    6
  * 题目 1
    * 在KMP算法中，已知模式串为ADABCADADA，请写出模式串的next数组值（ ）
      * A：-1,0,0,1,0,0,1,2,3,2
      * B：0,1,2,1,0,0,1,3,3,2
      * C：-1,0,0,0,1,0,1,2,3,2
      * D：1,0,0,1,0,0,1,2,2,3
    * 答案 A
      * "前缀"指除了最后一个字符以外，一个字符串的全部头部组合
      * "后缀"指除了第一个字符以外，一个字符串的全部尾部组合
      * next数组值就是"前缀"和"后缀"的最长的共有元素的长度。
      * 首先求最大相同前缀后缀长度。"A"的前缀和后缀都为空集，没有共有元素，共有元素长度为0；"AD"的前缀为\[A\]，后缀为\[D\]，没有共有元素，共有元素长度为0；"ADA"的前缀为 \[A, AD\]，后缀为\[DA, A\]，共有元素为A，长度为1；"ADAB"的前缀为\[A, AD, ADA\]，后缀为\[DAB, AB,B \]，共有元素长度为0；以此类推，最大公共元素长度为0,0,1,0,0,1,2,3,2。
      * 然后将最长相同前缀后缀长度值右移一位，并将next\[0\]初值赋为-1，得到的next数组：-1,0,0,1,0,0,1,2,3,2。
    * 题目2
      * 某二叉树的前序遍历序列为-+a_b-cd/ef，后序遍历序列为abcd-_+ef/-，问其中序遍历序列是\(\)
        * A:  a+b\*c-d-/ef
        * B:  f/e-d-b\*c+a
        * C:  a+b\*c-d-e/f
        * D:  a+b\*c-d-/fe
      * 答案：C
        * ![](/assets/root中序.png)
    * 题目3
      * 下列算法中，没有使用贪心策略的是（）
        * A:Prim 算法
        * B:Kruskal 算法
        * C:Dijkstra 算法
        * D: KMP 算法
      * 答案：D
        * 贪心策略是在对问题求解时，总是做出在当前看来是最好的选择，且缺少约束条件。也就是说，贪心策略不从整体最优上加以考虑，在某种意义上求得的是局部最优解。
        * Prim 算法属于贪心策略，先任意选择一个初始起点，构造顶点集，寻找与顶点集相邻权值最小的边和另一顶点，从而扩充顶点集，最后构造出最小生成树
        * Kruskal 算法通过合并顶点所在的子集合，选择边上权值最小的顶点集合进行联合，直到涵盖所有的顶点，生成最小生成树
        * Dijkstra 算法是解单源最短路径的贪心算法，通过扩充顶点集，不断做贪心选择来进行扩充
        * KMP 算法是一种改进的字符串匹配算法，时间复杂度是 O（m+n），主要使用的是递推的方法，没有涉及贪心策略
      * 题目4
        * 某一系统功能,需要一次性加载 N\(N 在 1000 左右\)个随机数,后续只对该集合进行遍历.下面那种结构那种最适宜\(\)
          * A: Hash 表
          * B: 链表
          * C: 图
          * D: 树
        * 答案： B
          * Hash 表不适合遍历，利用 Hash 算法来决定存储位置，
          * 链表适合遍历但是不适合随机访问
          * 图用于表示物件与物件之间关系的数学对象，但是不强调数据之间的关系，遍历效率不如链表
      * 题目5
        * 体育课的铃声响了，同学们都陆续地奔向操场，按老师的要求从高到矮站成一排。每个同学按顺序来到操场时，都从排尾走向排头，找到第一个比自己高的同学，并站到他的后面，这种站队的方法类似下列哪种算法？
          * A: 快速排序
          * B: 插入排序
          * C: 冒泡排序
          * D: 归并排序
        * 答案：B
          * 插入排序：将数据插入到已经排好序的序列中去，基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中的适当位置上，直到全部放入位置
      * 题目6
        * 设有一个栈，元素依次进栈的顺序是 A,B,C,D,E。下列不可能的出栈顺序有?
          * A：A,B,C,D,E
          * B: B,C,D,E,A
          * C: E,A,B,C,D
          * D: E,D,C,B,A
        * 答案： C
          1. A,B,C,D,E：先放入 A，取出 A，再放入 B，取出 B 依此类推
          2. B,C,D,E,A：先放入 A，再放入 B，取出 B，再放入 C，取 C，放入 D，取 D，放入 E，取 E，最后取出 A
          3. E,A,B,C,D：要想取出 E，则必须 ABCDE 都放入，取出 E 后不能直接取 A，所以是错误的
          4. E,D,C,B,A：放入 ABCDE，再依次取出 ABCDE
