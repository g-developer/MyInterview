* 分布：
  * 单选 2
  * 多选 1
* 多线程    3
  * 题目1
    * 并发操作会带来哪些数据不一致性（ ）
      * A：丢失修改、脏读、死锁
      * B：不可重复读、脏读、死锁
      * C：不可修改、不可重复读、脏读、死锁
      * D：丢失修改、不可重复读、脏读
    * 答案 D
      * 并发操作指的是多用户或多事务同时对同一数据进行操作。
      * 当两个或多个事务选择同一数据，并且基于最初选定的值修改该数据时，会发生丢失修改问题。每个事务都不知道其它事务的存在，最后的更新将重写由其它事务所做的更新，这将导致修改丢失。
      * 当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据。
      * 一个事务重新读取前面读取过的数据，发现该数据已经被另一个已提交的事务修改过。即事务1读取某一数据后，事务2对其做了修改，当事务1再次读数据时，得到的与第一次不同的值。在一个事务中前后两次读取的结果并不致，导致了不可重复读。
      * 死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
  * 题目2
    * 以下不是进程间通讯的是\(\)
      * A:共享内存
      * B:信号
      * C:线程局部存储
      * D:消息队列
    * 答案：C
      * 管道（pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。
      * 有名管道（named pipe）：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。
      * 信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
      * 消息队列（message queue）：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
      * 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。
      * 共享内存（shared memory）：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。
      * 套接字（socket）：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。
      * 区别
        * 共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据（配合信号量使用）；这种方式通常适用于多进程间通信
        * PIPE和FIFO用来实现进程间相互发送非常短小的、频率很高的消息；这两种方式通常适用于两个进程间的通信
        * 分布式开发。在多进程、多线程、多模块所构成的今天最常见的分布式系统开发中，socket是第一选择
        * PIPE和FIFO可以偶尔使用下，共享内存都用的不多了。在效率上说，socket有包装数据和解包数据的过程，所以理论上来说socket是没有PIPE/FIFO快。不过现在计算机上真心不计较这么一点点速度损失的。
        * 程间通信的数据一般来说我们都会存入数据库的，这样万一某个进程突然死掉或者整个服务器死了，也不至于丢失重要数据、便于回滚到之前的状态
        * 共享内存的效率确实高，但它的重点在“共享”二字上。如果的确有好些进程共享一大块数据。如果把每个进程都看做是类的对象的话，那么共享数据就是这个类的static数据成员），那么共享内存就是一个不二的选择了。但是在面向对象的今天，我们更多的时候是多线程+锁+线程间共享数据。因此共享进程在今天使用的也越来越少了
        * 在面对一些极度追求效率的需求时，共享内存就会成为唯一的选择，比如高频交易系统。除此以外，一般是不需要特意使用共享内存的
        * PIPE和共享内存是不能跨LAN的（FIFO可以但FIFO只能用于两个进程通信）。如果你的分布式系统随着需求的增加而越来越大所以你想把不同的模块放在不同机器上而你之前开发的时候用了PIPE或者共享内存，那么你将不得不对代码进行大幅修改。同时，即使FIFO可以跨越LAN，其代码的可读性、易操作性和可移植性、适应性也远没有socket大
        * 信号的局限性：不能跨LAN、信息量极其有限
  * 题目3
    * 产生死锁的条件是（ ）
      * A：资源不能被共享
      * B：请求与保持条件
      * C：非剥夺条件
      * D：循环等待条件
    * 答案 A.B.C.D
      * 资源不能被共享，只能由一个进程使用。
      * 请求与保持条件（Hold and wait）：已经得到资源的进程可以再次申请新的资源。
      * 非剥夺条件（No pre-emption）：已经分配的资源不能从相应的进程中被强制地剥夺。
      * 循环等待条件（Circular wait）：系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。